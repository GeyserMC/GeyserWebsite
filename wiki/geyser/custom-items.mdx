---
title: Custom Items
description: Geyser allows custom Bedrock items to be added for an equivalency to Vanilla Java item predicates or modded items.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Minecraft: Java Edition supports "custom" items that are based on vanilla items. With Minecraft 1.21.4+, the introduction of item components
made it possible to customize item behavior like never before - therefore making it possible to create custom items using
resource packs, and a datapack / plugin on the server.

Unlike Java Edition, Bedrock natively supports adding custom items that are not based on vanilla items. However, Bedrock does not support
extending vanilla items or modifying vanilla item behavior. Therefore, Geyser has a mapping system that allows mapping custom Bedrock items
to modified vanilla Java items. Geyser further supports mapping custom Bedrock items to modded non-vanilla items which
would require modded Java clients.

To setup custom items in Geyser, you have to choose how you are going to register your items. The easiest is [using a json file](#json-mappings), but you can also [use a Geyser extension](#geyser-extensions).
Further, a Bedrock edition resource pack must also be supplied to ensure Bedrock players can see custom items.

:::warning
Geyser does not convert resource packs from Java Edition, and also does not generate mappings automatically.
However, you can use automatic tools such as [Rainbow](/wiki/other/rainbow/) to make converting content simpler.
:::

### Format version 1 (legacy)

<details>
<summary>Click to see legacy documentation for format version 1</summary>

:::warning
`format_version: 1` is no longer receiving updates. New features will only be added to format version 2.
:::

## JSON mappings

1. Start your server, and you should have a folder called `custom_mappings` that is created. That would be with the folder of `Geyser.jar` file for standalone and inside your Geyser data folder for a plugin.
2. Create a `.json` file, it can be any name you like and as many files as you like. You don't need to make one file per item. Here is the structure of the file:
```json
{
    "format_version": 1,
    "items": {

    }
}
```
3. Inside the `items` entry, you can add your java item to extend:

```json
"minecraft:JAVA_ITEM": [

]
```
4. Inside this java item, goes an array of all your custom items.

```json
{
    "name": "my_item"
}
```
5. Then, you need to set one or more item options or registrations, they can be stacked, so that all of the specified types need to match.
    * Custom model data: `custom_model_data` (int)
    * Damage predicate: `damage_predicate` (int) This is a fractional value of damage/max damage and not a number between 0 and 1.
    * Unbreakable: `unbreakable` (boolean)
6. You also have some extra modifiers that you can set to further customise your item. **Note that the following modifiers are NOT required.**
    * `display_name` (string) default: item name
    * `icon` (string) default: item name
    * `allow_offhand` (boolean) default: false
    * `texture_size` (int) default: 16
    * `creative_category` (int) default: not set. This can take values between 1-5, and defines the creative category the item appears in. Note: Adding your item to a creative category is needed if you want recipes that output this custom item to show up in the recipe book! However, including it does NOT mean you can get the custom item from the creative inventory.
    * `creative_group` (string) default: not set. Requires a creative category to also be set - allows you to group the custom item in a sub-group. See [here](https://wiki.bedrock.dev/documentation/menu-categories.html#list-of-categories) for all categories.
    * `render_offsets` (object) It works as follows. Note that all the sub-objects are optional, except x, y and z. You can have for example only a main hand with a position, and noting else. default: no render offset
    * `tags` (array) default: no tags. Allows defining tags that can be used in Molang queries. Example value: ["test:tag_one", "test:tag_two"].
    ```json
    "render_offsets": {
        "main_hand": {
            "first_person": {
                "position": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                },
                "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                },
                "scale": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                }
            },
            "third_person": {

            }
        },
        "off_hand": {

        }
    }
    ```

## Geyser extensions

### Extending a vanilla item

1. Create your custom item options or registrations, to which you can add any of the following. They can be stacked, so that all of the specified types need to match, but you **do NOT need all of them.**
```java
CustomItemOptions itemOptions = CustomItemOptions.builder()
        .customModelData(1)
        .damagePredicate(1) //This is a fractional value of damage/max damage and not a number between 0 and 1.
        .unbreakable(true)
        .build();
```
2. Create your custom item, and store it somewhere:
```java
CustomItemData data = CustomItemData.builder()
        .name("my_item")
        .customItemOptions(itemOptions)
        .build();
```
3. You have some modifiers that you can set to further customise your item. **Note that the following modifiers are NOT required.**
```java
.displayName("displayName"); //Default: item name
.icon("my_icon"); //Default: item name
.allowOffhand(false); //Default: false
.textureSize(16); //Default: 16
.renderOffsets(new CustomRenderOffsets(...)); //Default: no render offset
```
4. Then, in your pre init event, you can register your item:
```java
@Subscribe
public void onGeyserPreInitializeEvent(GeyserDefineCustomItemsEvent event) {
    event.registerCustomItem("minecraft:JAVA_ITEM", data);
}
```

### Non vanilla (modded) items with Geyser extensions (for example to use with Fabric)

1. Create your item data:
```java
NonVanillaCustomItemData data = NonVanillaCustomItemData.builder()
        .name("my_item")
        .identifier("my_mod:my_item")
        .javaId(1)
```
2. There are many other options you can set to match the behavior that you require for your item. You can see them [here](https://github.com/GeyserMC/Geyser/blob/master/api/src/main/java/org/geysermc/geyser/api/item/custom/NonVanillaCustomItemData.java)
3. Register your item in the GeyserDefineCustomItems event:
```java
@Subscribe
public void onGeyserDefineCustomItemsEvent(GeyserDefineCustomItemsEvent event) {
    event.register(data);
}
```

## Resource pack

1. Setup a basic bedrock resource pack. If you need help, you can find it [here](https://wiki.bedrock.dev/guide/project-setup.html#rp-manifest).
2. Make a `textures` folder.
3. Create `item_texture.json` in the `textures`, and put this in it:

```json
{
  "resource_pack_name": "MY_PACK_NAME_HERE",
  "texture_name": "atlas.items",
  "texture_data": {
    
  }
}
```
4. Inside texture data, you can add your items. The texture name and path must match the name that you set in your mappings.

```json
"my_item": {
    "textures": [
        "textures/items/my_item"
    ]
}
```
5. Then you need to put your textures inside the `textures/items`. Make sure to have it match the texture path that you specified in `item_texture.json`!
</details>

## Format version 2
With Geyser build 1020 (and above), Geyser supports the `item_model` and item component features introduced in 1.21.4+.
Unlike Java Edition, Bedrock Edition does not support modifying item properties dynamically at runtime (e.g. making dirt edible with a command).
For such use-cases, Geyser supports registering multiple custom Bedrock items with different properties to somewhat support dynamic mappings using
predicates. The previous `custom-model-data` approach continues to be supported using `legacy` definitions.

## How does it work?
This section explains how item mappings work in Geyser, how they can be created, and lists all configurable options.

### Prerequisites: Vocabulary
- `Java item`: Any vanilla item that exists in the Minecraft: Java Edition base game. Java datapacks make custom items by overriding the components of a Java item.
- `Java item component`: On Java Edition, items have their properties and behaviour defined using item components.
Every Java item has a set of default components, and item stacks can override these components to remove or modify them.
- `Bedrock item component`: Custom Bedrock items also have components that determine item behaviour, similar to Java Edition.
However, these components cannot be changed at runtime for item stacks and have to be defined once.
- `Java legacy custom model data`: The system used before Java 1.21.4. Before 1.21.4, each "custom item" had a custom model data number,
used to decide which model a Java item should use (= different texture for players).
- `Java item model definition`: Introduced in Java 1.21.4, they are found in the `assets/<namespace>/items/` directory of Java resource packs.
These textures are used to set the appearance of Java items, and can be dynamically changed with a set of rules and item properties.
Every Java item stores its item model definition in the `minecraft:item_model` item data component. It can be overridden on a per-item-stack-basis by a datapack/plugin to use a custom item model definition defined in a resource pack.
- `Custom item definition`: a custom item definition is a Geyser term. It represents a single Bedrock custom item that is used to map a Java item model definition. It contains info on the item's properties on Java and Bedrock.
Multiple custom item definitions, and thus multiple Bedrock items, can exist for the same Java item model definition, but for every combination of a Java item and Java item model definition, there can only be one custom item definition without predicates.
- `Non-vanilla custom item definition`: also a Geyser term. Represents a Bedrock custom item that maps a Java non-vanilla (modded) item. Like normal custom item definitions, it contains info on the item's properties on Java and Bedrock.
At the moment, there can only be one non-vanilla custom item definition per Java non-vanilla item.

## Creating mappings

<Tabs>
    <TabItem value="using-json" label="Json mapping files">

    </TabItem>

    <TabItem value="using-api" label="Using Geyser API">

    </TabItem>
</Tabs>

## Examples for mapping vanilla items

The full Java Edition datapack + resource pack, as well as the relevant Geyser mappings and Bedrock resource pack can be found
[here](https://github.com/eclipseisoffline/geyser-example-mappings/).

<Tabs> <TabItem value="json-mapping" label="Json mapping example">

    <details>
    <summary>Simple custom food item mapping</summary>
        ```json
        {
            "format_version": 2,
            "items": {
                "minecraft:flint": [
                    {
                        "type": "definition",
                        "model": "geyser_mc:yummy_food",
                        "bedrock_identifier": "geyser_mc:yummy_food",
                        "display_name": "Yummy food!",
                        "components": {
                            "minecraft:consumable": {},
                            "minecraft:food": {
                                "nutrition": 5,
                                "saturation": 0.0
                            },
                            "minecraft:max_stack_size": 16
                        }
                    }
                ]
            }
        }
        ```
    </details>

    <details>
    <summary>Not-yummy-food - group and dimension predicate example</summary>
    ```json
        {
            "format_version": 2,
            "items": {
                "minecraft:flint": [
                    {
                        "type": "group",
                        "model": "geyser_mc:not_so_yummy_food",
                        "definitions": [
                            {
                                "bedrock_identifier": "geyser_mc:not_so_yummy_food",
                                "display_name": "Not so yummy food",
                                "components": {
                                    "minecraft:consumable": {
                                        "consume_seconds": 5.0
                                    },
                                    "minecraft:food": {
                                        "nutrition": 2,
                                        "saturation": 0.7
                                    }
                                }
                            },
                            {
                                "bedrock_identifier": "geyser_mc:not_so_yummy_food_end",
                                "display_name": "Not so yummy food",
                                "predicate": {
                                    "type": "match",
                                    "property": "context_dimension",
                                    "value": "minecraft:the_end"
                                },
                                "components": {
                                    "minecraft:consumable": {
                                        "consume_seconds": 5.0
                                    },
                                    "minecraft:food": {
                                        "nutrition": 2,
                                        "saturation": 0.7
                                    }
                                }
                            }
                        ]
                    }
                ]
            }
        }
        ```
    </details>

    <details>
    <summary>Magic item (consumable with cooldown)</summary>
    ```json
        {
            "format_version": 2,
            "items": {
                "minecraft:flint": [
                    {
                        "type": "definition",
                        "model": "geyser_mc:magic_item",
                        "bedrock_identifier": "geyser_mc:magic_item",
                        "display_name": "Magic item",
                        "components": {
                            "minecraft:consumable": {
                                "consume_seconds": 0.05,
                                "animation": "none"
                            },
                            "minecraft:use_cooldown": {
                                "seconds": 5.0,
                                "cooldown_group": "geyser_mc:magic_item"
                            }
                        }
                    }
                ]
            }
        }
        ```
    </details>

    <details>
    <summary>Flint pickaxe (broken-state predicate)</summary>
    ```json
        {
            "format_version": 2,
            "items": {
                "minecraft:flint": [
                    {
                        "type": "group",
                        "model": "geyser_mc:flint_pickaxe",
                        "definitions": [
                            {
                                "bedrock_identifier": "geyser_mc:flint_pickaxe",
                                "display_name": "Flint Pickaxe",
                                "bedrock_options": {
                                    "display_handheld": true
                                },
                                "components": {
                                    "minecraft:max_damage": 10,
                                    "minecraft:max_stack_size": 1
                                }
                            },
                            {
                                "bedrock_identifier": "geyser_mc:flint_pickaxe_broken",
                                "display_name": "Flint Pickaxe",
                                "bedrock_options": {
                                    "display_handheld": true
                                },
                                "predicate": {
                                    "type": "condition",
                                    "property": "broken"
                                },
                                "components": {
                                    "minecraft:max_damage": 10,
                                    "minecraft:max_stack_size": 1
                                }
                            }
                        ]
                    }
                ]
            }
        }
        ```
    </details>

    <details>
    <summary>Red wool chestplate (equippable armor)</summary>
        ```json
        {
            "format_version": 2,
            "items": {
                "minecraft:flint": [
                    {
                        "type": "definition",
                        "model": "geyser_mc:red_wool_chestplate",
                        "bedrock_identifier": "geyser_mc:red_wool_chestplate",
                        "display_name": "Red Wool Chestplate",
                        "bedrock_options": {
                            "protection_value": 5
                        },
                        "components": {
                            "minecraft:equippable": {
                                "slot": "chest"
                            },
                            "minecraft:max_stack_size": 1
                        }
                    }
                ]
            }
        }

        ```
    </details>

</TabItem> <TabItem value="code" label="Code example">

    <details>
        <summary>Simple custom food item mapping</summary>
        ```java
        @Subscribe
        public void onDefineCustomItems(GeyserDefineCustomItemsEvent event) {
            Identifier bedrockIdentifier = Identifier.of("geyser_mc:yummy_food");
            Identifier modelIdentifier = Identifier.of("geyser_mc:yummy_food");
            event.register(Identifier.of("flint"), CustomItemDefinition.builder(bedrockIdentifier, modelIdentifier)
                .displayName("Yummy food!")
                .component(ItemDataComponents.CONSUMABLE, Consumable.builder().build())
                .component(ItemDataComponents.FOOD, FoodProperties.builder()
                    .nutrition(5)
                    .saturation(0)
                    .build())
                .component(ItemDataComponents.MAX_STACK_SIZE, 16)
                .build());
        }
        ```
    </details>

    <details>
        <summary>Not-yummy-food - group and dimension predicate example</summary>
        ```java
        @Subscribe
        public void onDefineCustomItems(GeyserDefineCustomItemsEvent event) {
            Identifier modelIdentifier = Identifier.of("geyser_mc:not_so_yummy_food");
            event.register(Identifier.of("flint"), CustomItemDefinition.builder(Identifier.of("geyser_mc:not_so_yummy_food"), modelIdentifier)
                .displayName("Not so yummy food!")
                .component(ItemDataComponents.CONSUMABLE, Consumable.builder()
                    .consumeSeconds(5)
                    .build())
                .component(ItemDataComponents.FOOD, FoodProperties.builder()
                    .nutrition(2)
                    .saturation(0.7f)
                    .build())
                .build());

            event.register(Identifier.of("flint"), CustomItemDefinition.builder(Identifier.of("geyser_mc:not_so_yummy_food_end"), modelIdentifier)
                .displayName("Not so yummy food!")
                .predicate(MatchPredicate.dimension(Identifier.of("the_end")))
                .component(ItemDataComponents.CONSUMABLE, Consumable.builder()
                    .consumeSeconds(5)
                    .build())
                .component(ItemDataComponents.FOOD, FoodProperties.builder()
                    .nutrition(2)
                    .saturation(0.7f)
                    .build())
                .build());
        }
        ```
    </details>

    <details>
        <summary>Magic item (consumable with cooldown)</summary>
        ```java
        @Subscribe
        public void onDefineCustomItems3(GeyserDefineCustomItemsEvent event) {
            Identifier bedrockIdentifier = Identifier.of("geyser_mc:magic_item");
            Identifier modelIdentifier = Identifier.of("geyser_mc:magic_item");
            event.register(Identifier.of("flint"), CustomItemDefinition.builder(bedrockIdentifier, modelIdentifier)
                .displayName("Magic item!")
                .component(ItemDataComponents.CONSUMABLE, Consumable.builder()
                    .consumeSeconds(0.05f)
                    .animation(Consumable.Animation.NONE)
                    .build())
                .component(ItemDataComponents.USE_COOLDOWN, UseCooldown.builder()
                    .seconds(5)
                    .cooldownGroup(modelIdentifier)
                    .build())
                .component(ItemDataComponents.MAX_STACK_SIZE, 16)
                .build());
        }
        ```
    </details>

    <details>
        <summary>Flint pickaxe (broken-state predicate)</summary>
        ```java
        @Subscribe
        public void onDefineCustomItems4(GeyserDefineCustomItemsEvent event) {
            event.register(Identifier.of("flint"), CustomItemDefinition.builder(
                    Identifier.of("geyser_mc:flint_pickaxe"), Identifier.of("geyser_mc:flint_pickaxe")
                )
                .displayName("Flint Pickaxe")
                .bedrockOptions(CustomItemBedrockOptions.builder()
                    .displayHandheld(true)
                )
                .component(ItemDataComponents.MAX_DAMAGE, 10)
                .component(ItemDataComponents.MAX_STACK_SIZE, 1)
                .build());

            event.register(Identifier.of("flint"), CustomItemDefinition.builder(
                    Identifier.of("geyser_mc:flint_pickaxe_broken"), Identifier.of("geyser_mc:flint_pickaxe")
                )
                .displayName("Flint Pickaxe")
                .bedrockOptions(CustomItemBedrockOptions.builder()
                    .displayHandheld(true)
                )
                .predicate(ItemConditionPredicate.BROKEN)
                .component(ItemDataComponents.MAX_DAMAGE, 10)
                .component(ItemDataComponents.MAX_STACK_SIZE, 1)
                .build());
        }
        ```
    </details>

    <details>
        <summary>Red wool chestplate (equippable armor)</summary>
        ```java
        @Subscribe
        public void onDefineCustomItems5(GeyserDefineCustomItemsEvent event) {
            event.register(Identifier.of("flint"), CustomItemDefinition.builder(
                    Identifier.of("geyser_mc:red_wool_chestplate"), Identifier.of("geyser_mc:red_wool_chestplate")
                )
                .displayName("Red Wool Chestplate")
                .bedrockOptions(CustomItemBedrockOptions.builder()
                    .protectionValue(5)
                )
                .component(ItemDataComponents.EQUIPPABLE, Equippable.of(Equippable.EquipmentSlot.CHEST))
                .component(ItemDataComponents.MAX_STACK_SIZE, 1)
                .build());
        }
        ```
    </details>
</TabItem> </Tabs>

## Resource Packs
Custom items also require a Bedrock Edition resource pack. Geyser does not generate or convert Java Edition resource packs into
Bedrock Edition resource packs, so you will need to set it up manually! You can also try using [Rainbow](/wiki/other/rainbow) or
other third-party converters.

### Creating your own Bedrock Edition resource pack

1. Setup a basic bedrock resource pack with a valid manifest. If you need help, you can find it [here](https://wiki.bedrock.dev/guide/project-setup.html#rp-manifest).
2. Create a `textures` folder.
3. In that folder, create an `item_texture.json` file, and put this in it:

```json
{
  "resource_pack_name": "YOUR_PACK_NAME",
  "texture_name": "atlas.items",
  "texture_data": {

  }
}
```
4. Inside `texture_data`, you can add your items. The texture name and path must match the Bedrock identifier (and/or icon) that you set in your mappings.
For example, an item registered with the Bedrock identifier `example:yummy_food` would need the following entry:

```json
"example:yummy_food": {
    "textures": [
        "textures/items/yummy_food"
    ]
}
```
5. Then you need to put your textures inside the `textures/items` folder. Make sure to have it match the texture path that you specified in `item_texture.json`!

### Further references:
- [Minecraft creator docs on texture pack conversion](https://learn.microsoft.com/en-us/minecraft/creator/documents/convertingtexturepacks?view=minecraft-bedrock-stable)
- [Creating textures for custom items](https://wiki.bedrock.dev/items/items-intro#applying-textures)
- [High resolution items](https://wiki.bedrock.dev/items/high-resolution-items)


## Loading mappings and resource packs
This section assumes you already set up and configured Geyser so Bedrock players are able to connect. Further, the `enable-custom-content`
config option in Geyser's config must be set to `true` for custom items to work!

<Tabs>
    <TabItem value="json-mapping" label="Loading json mappings">
        1. Find the `custom_mappings` folder created by Geyser. For plugin/mod versions of Geyser, it will be under
        `plugins/Geyser-[platform]/custom_mappings` (or `config/Geyser-[platform]/custom_mappings`). For Geyser-Standalone,
        it will be in the root folder.
        2. Place the mapping .json file into the folder. You can have multiple mapping files with different file names.
        3. Place the Bedrock edition resource pack into the `packs` folder.
        4. Restart the server.
    </TabItem>

    <TabItem value="geyser-extension" label="Loading Geyser Extensions">
        1. Place the extension jar file into the `extensions` folder. For plugin/mod versions of Geyser, it will be under
        `plugins/Geyser-[platform]/extensions` (or `config/Geyser-[platform]/extensions`). For Geyser-Standalone,
        it will be in the root folder.
        2. If the extension also provides a resource pack, place that in Geyser's `packs` folder.
        3. Restart the server.
    </TabItem>
</Tabs>

# FAQ

TODO